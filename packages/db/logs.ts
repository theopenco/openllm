import type { tables } from "./src";
import type { InferInsertModel } from "drizzle-orm";

type Log = InferInsertModel<typeof tables.log>;

export const logs: Log[] = [
	{
		id: "test-log-id-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 100,
		requestedModel: "gpt-4",
		requestedProvider: "openai",
		usedModel: "gpt-4",
		usedProvider: "openai",
		responseSize: 1000,
		content: "Test response content",
		finishReason: "stop",
		promptTokens: 10,
		completionTokens: 20,
		totalTokens: 30,
		temperature: 0.7,
		maxTokens: 100,
		messages: JSON.stringify([{ role: "user", content: "Hello" }]),
	},
	{
		id: "log-gpt4-turbo-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 2345,
		requestedModel: "gpt-4-turbo",
		requestedProvider: "openai",
		usedModel: "gpt-4-turbo",
		usedProvider: "openai",
		responseSize: 3782,
		content:
			"I've analyzed your code and found several potential optimizations. First, you're creating multiple database connections which can lead to connection pool exhaustion. Second, your query isn't using indexes effectively. I recommend adding an index on the 'created_at' column and restructuring your query to use a JOIN instead of a subquery. This should significantly improve performance for large datasets.",
		finishReason: "stop",
		promptTokens: 512,
		completionTokens: 128,
		totalTokens: 640,
		temperature: 0.2,
		maxTokens: 1000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"I have a performance issue with this database query. Can you help optimize it? SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE created_at > '2023-01-01' AND status = 'completed') ORDER BY last_login DESC LIMIT 100;",
			},
		]),
	},
	{
		id: "log-claude-opus-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "anthropic-key-id",
		duration: 4231,
		requestedModel: "claude-3-opus",
		requestedProvider: "anthropic",
		usedModel: "claude-3-opus",
		usedProvider: "anthropic",
		responseSize: 8954,
		content:
			"Here's a comprehensive React component that implements the data visualization dashboard you described. I've included responsive design considerations, accessibility features, and proper TypeScript typing throughout. The component uses React hooks for state management and includes error handling for API failures. I've also added detailed comments to explain the implementation choices.",
		finishReason: "stop",
		promptTokens: 1024,
		completionTokens: 2048,
		totalTokens: 3072,
		temperature: 0.5,
		maxTokens: 4000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"I need to create a data visualization dashboard for our analytics platform. It should display real-time metrics, allow filtering by date range, and include both chart and tabular views. Can you help me design a React component for this?",
			},
		]),
	},
	{
		id: "log-gpt35-turbo-1",
		createdAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		updatedAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 987,
		requestedModel: "gpt-3.5-turbo",
		requestedProvider: "openai",
		usedModel: "gpt-3.5-turbo",
		usedProvider: "openai",
		responseSize: 1245,
		content:
			"To fix this CSS issue, you need to add 'position: relative' to the parent container and then use 'position: absolute' with appropriate top/left values for the child element. Also, make sure to set a z-index if you want to control stacking order.",
		finishReason: "stop",
		promptTokens: 156,
		completionTokens: 89,
		totalTokens: 245,
		temperature: 0.7,
		maxTokens: 500,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"I'm having trouble with CSS positioning. My dropdown menu appears behind other elements even though I've set z-index. How can I fix this?",
			},
		]),
	},
	{
		id: "log-llama3-70b-1",
		createdAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		updatedAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "meta-key-id",
		duration: 3567,
		requestedModel: "llama-3-70b",
		requestedProvider: "meta",
		usedModel: "llama-3-70b",
		usedProvider: "meta",
		responseSize: 5432,
		content:
			"I've reviewed your machine learning pipeline and identified several areas for improvement. Your feature engineering approach could benefit from dimensionality reduction techniques like PCA or t-SNE before feeding data into your model. Additionally, your current model architecture might be suffering from overfitting - I suggest implementing dropout layers and regularization. Finally, your evaluation metrics should include precision-recall curves since you're dealing with an imbalanced dataset.",
		finishReason: "stop",
		promptTokens: 789,
		completionTokens: 432,
		totalTokens: 1221,
		temperature: 0.4,
		maxTokens: 2000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"Can you review my machine learning pipeline for sentiment analysis? I'm using BERT embeddings with a custom classifier on top, but my accuracy is only around 78% which seems low.",
			},
		]),
	},
	{
		id: "log-claude-sonnet-1",
		createdAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		updatedAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "anthropic-key-id",
		duration: 1876,
		requestedModel: "claude-3-sonnet",
		requestedProvider: "anthropic",
		usedModel: "claude-3-sonnet",
		usedProvider: "anthropic",
		responseSize: 3210,
		content:
			"Based on your requirements, I've created a Docker Compose configuration that sets up a development environment with PostgreSQL, Redis, and your Node.js application. The configuration includes volume mounts for data persistence, environment variables for configuration, and proper networking between services. I've also added health checks to ensure dependencies are ready before your application starts.",
		finishReason: "stop",
		promptTokens: 345,
		completionTokens: 567,
		totalTokens: 912,
		temperature: 0.3,
		maxTokens: 1500,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"I need help setting up a Docker Compose file for my Node.js application. It should include PostgreSQL and Redis services.",
			},
		]),
	},
	{
		id: "log-gpt4-vision-1",
		createdAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		updatedAt: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 5432,
		requestedModel: "gpt-4-vision",
		requestedProvider: "openai",
		usedModel: "gpt-4-vision",
		usedProvider: "openai",
		responseSize: 2876,
		content:
			"The UI mockup you've shared has several usability issues. The contrast ratio between the text and background doesn't meet WCAG accessibility standards. The navigation menu items are too close together, making them difficult to tap on mobile devices. I also notice that the form lacks proper validation indicators and the submit button doesn't have a clear hover state. I recommend increasing text contrast, adding more padding between navigation items, implementing clear form validation states, and enhancing button interactivity.",
		finishReason: "stop",
		promptTokens: 1543,
		completionTokens: 321,
		totalTokens: 1864,
		temperature: 0.2,
		maxTokens: 1000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"Can you review this UI mockup and provide feedback on usability and accessibility? [image content]",
			},
		]),
	},
	{
		id: "log-mistral-large-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "mistral-key-id",
		duration: 2134,
		requestedModel: "mistral-large",
		requestedProvider: "mistral",
		usedModel: "mistral-large",
		usedProvider: "mistral",
		responseSize: 4321,
		content:
			"Your Kubernetes deployment is experiencing issues due to resource constraints. The pods are being terminated because they're exceeding their memory limits. I recommend increasing the memory request and limit in your deployment YAML. Additionally, you should implement horizontal pod autoscaling based on memory utilization to handle varying loads. Finally, consider implementing a liveness probe with appropriate parameters to prevent Kubernetes from killing pods during temporary spikes.",
		finishReason: "stop",
		promptTokens: 432,
		completionTokens: 321,
		totalTokens: 753,
		temperature: 0.4,
		maxTokens: 1200,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"My Kubernetes pods keep getting OOMKilled. Here's my deployment YAML and the recent logs. Can you help me diagnose and fix the issue?",
			},
		]),
	},
	{
		id: "log-gpt4-code-interpreter-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 8765,
		requestedModel: "gpt-4-code-interpreter",
		requestedProvider: "openai",
		usedModel: "gpt-4-code-interpreter",
		usedProvider: "openai",
		responseSize: 9876,
		content:
			"I've analyzed your sales data and created visualizations showing trends over time. There's a clear seasonal pattern with peaks in December and July. Your year-over-year growth is approximately 12.3%, but profit margins have decreased by 2.1% in the same period. The best-performing product category is 'Electronics' with 34% of total revenue, while 'Home Goods' has the highest profit margin at 28%. I've also identified potential inventory optimization opportunities that could reduce carrying costs by approximately 15%.",
		finishReason: "stop",
		promptTokens: 2345,
		completionTokens: 1234,
		totalTokens: 3579,
		temperature: 0.1,
		maxTokens: 4000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"I have this CSV file with our company's sales data for the past 3 years. Can you analyze it and provide insights on trends, best-performing products, and areas for improvement?",
			},
		]),
	},
	{
		id: "log-claude-haiku-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "anthropic-key-id",
		duration: 543,
		requestedModel: "claude-3-haiku",
		requestedProvider: "anthropic",
		usedModel: "claude-3-haiku",
		usedProvider: "anthropic",
		responseSize: 987,
		content:
			"To implement JWT authentication in your Express.js API, you'll need to: 1) Install the jsonwebtoken package, 2) Create a middleware function to verify tokens, 3) Generate tokens during login, and 4) Apply the middleware to protected routes. I've included sample code for each step below.",
		finishReason: "stop",
		promptTokens: 123,
		completionTokens: 234,
		totalTokens: 357,
		temperature: 0.6,
		maxTokens: 800,
		messages: JSON.stringify([
			{
				role: "user",
				content: "How do I implement JWT authentication in my Express.js API?",
			},
		]),
	},
	{
		id: "log-gpt4-error-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "test-provider-key-id",
		duration: 234,
		requestedModel: "gpt-4",
		requestedProvider: "openai",
		usedModel: "gpt-4",
		usedProvider: "openai",
		responseSize: 0,
		content: null,
		finishReason: "content_filter",
		promptTokens: 567,
		completionTokens: 0,
		totalTokens: 567,
		temperature: 0.7,
		maxTokens: 2000,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"Write me a script that can be used to exploit security vulnerabilities in a website.",
			},
		]),
	},
	{
		id: "log-llama3-8b-1",
		projectId: "test-project-id",
		apiKeyId: "test-api-key-id",
		providerKeyId: "meta-key-id",
		duration: 1234,
		requestedModel: "llama-3-8b",
		requestedProvider: "meta",
		usedModel: "llama-3-8b",
		usedProvider: "meta",
		responseSize: 2345,
		content:
			"Here's a Python function that implements the algorithm you described. It has O(n log n) time complexity and O(n) space complexity. I've included comments to explain the key steps and added error handling for edge cases.",
		finishReason: "length",
		promptTokens: 345,
		completionTokens: 500,
		totalTokens: 845,
		temperature: 0.5,
		maxTokens: 500,
		messages: JSON.stringify([
			{
				role: "user",
				content:
					"Can you implement an efficient algorithm to find the longest increasing subsequence in an array of integers?",
			},
		]),
	},
];
